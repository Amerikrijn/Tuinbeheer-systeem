-- User System Migration Script
-- Version: 1.0.0
-- Description: Adds comprehensive user management, roles, and tracking to the garden management system

-- =======================
-- 1. CREATE CUSTOM TYPES
-- =======================

CREATE TYPE app_role AS ENUM ('admin', 'user');
CREATE TYPE user_status AS ENUM ('pending', 'active', 'inactive');
CREATE TYPE app_permission AS ENUM (
  'gardens.create', 'gardens.edit', 'gardens.delete', 'gardens.view',
  'plant_beds.create', 'plant_beds.edit', 'plant_beds.delete', 'plant_beds.view',
  'plants.create', 'plants.edit', 'plants.delete', 'plants.view',
  'tasks.create', 'tasks.edit', 'tasks.delete', 'tasks.complete', 'tasks.view',
  'logbook.create', 'logbook.edit', 'logbook.delete', 'logbook.view',
  'users.invite', 'users.manage', 'users.view'
);

-- =======================
-- 2. CREATE USERS TABLE
-- =======================

CREATE TABLE public.users (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  email TEXT NOT NULL UNIQUE,
  full_name TEXT,
  avatar_url TEXT,
  role app_role NOT NULL DEFAULT 'user',
  status user_status NOT NULL DEFAULT 'pending',
  invited_by UUID REFERENCES public.users(id),
  invited_at TIMESTAMP WITH TIME ZONE,
  last_login TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  -- Constraints
  CONSTRAINT users_email_valid CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'),
  CONSTRAINT users_full_name_length CHECK (LENGTH(full_name) >= 2 AND LENGTH(full_name) <= 100)
);

-- =======================
-- 3. CREATE USER PERMISSIONS TABLE
-- =======================

CREATE TABLE public.user_permissions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,
  permission app_permission NOT NULL,
  granted_by UUID REFERENCES public.users(id),
  granted_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  -- Ensure unique permission per user
  UNIQUE(user_id, permission)
);

-- =======================
-- 4. CREATE ROLE PERMISSIONS TABLE
-- =======================

CREATE TABLE public.role_permissions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  role app_role NOT NULL,
  permission app_permission NOT NULL,
  
  -- Ensure unique permission per role
  UNIQUE(role, permission)
);

-- =======================
-- 5. CREATE USER GARDEN ACCESS TABLE
-- =======================

CREATE TABLE public.user_garden_access (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,
  garden_id UUID REFERENCES public.gardens(id) ON DELETE CASCADE NOT NULL,
  granted_by UUID REFERENCES public.users(id),
  granted_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  -- Unique constraint to prevent duplicate access
  UNIQUE(user_id, garden_id)
);

-- =======================
-- 6. CREATE AUDIT LOG TABLE
-- =======================

CREATE TABLE public.audit_log (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES public.users(id),
  action_type TEXT NOT NULL,
  table_name TEXT NOT NULL,
  record_id TEXT NOT NULL,
  old_values JSONB,
  new_values JSONB,
  ip_address INET,
  user_agent TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- =======================
-- 6. EXTEND EXISTING TABLES
-- =======================

-- Check if tasks table exists, if not create it
CREATE TABLE IF NOT EXISTS tasks (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  title TEXT NOT NULL,
  description TEXT,
  due_date DATE,
  completed BOOLEAN DEFAULT FALSE,
  completed_at TIMESTAMP WITH TIME ZONE,
  priority TEXT DEFAULT 'medium' CHECK (priority IN ('low', 'medium', 'high')),
  task_type TEXT DEFAULT 'general',
  plant_id UUID REFERENCES plants(id) ON DELETE CASCADE,
  plant_bed_id TEXT REFERENCES plant_beds(id) ON DELETE CASCADE,
  notes TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Check if logbook_entries table exists, if not create it
CREATE TABLE IF NOT EXISTS logbook_entries (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  plant_bed_id TEXT REFERENCES plant_beds(id) ON DELETE CASCADE NOT NULL,
  plant_id UUID REFERENCES plants(id) ON DELETE CASCADE,
  entry_date DATE NOT NULL,
  notes TEXT NOT NULL,
  photo_url TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add user tracking columns to existing tables
ALTER TABLE tasks ADD COLUMN IF NOT EXISTS completed_by UUID REFERENCES public.users(id);
ALTER TABLE tasks ADD COLUMN IF NOT EXISTS created_by UUID REFERENCES public.users(id);

ALTER TABLE logbook_entries ADD COLUMN IF NOT EXISTS created_by UUID REFERENCES public.users(id);
ALTER TABLE logbook_entries ADD COLUMN IF NOT EXISTS updated_by UUID REFERENCES public.users(id);

ALTER TABLE gardens ADD COLUMN IF NOT EXISTS created_by UUID REFERENCES public.users(id);
ALTER TABLE plant_beds ADD COLUMN IF NOT EXISTS created_by UUID REFERENCES public.users(id);
ALTER TABLE plants ADD COLUMN IF NOT EXISTS created_by UUID REFERENCES public.users(id);

-- =======================
-- 7. CREATE INDEXES
-- =======================

-- Users table indexes
CREATE INDEX idx_users_email ON public.users(email);
CREATE INDEX idx_users_role ON public.users(role);
CREATE INDEX idx_users_status ON public.users(status);
CREATE INDEX idx_users_invited_by ON public.users(invited_by);
CREATE INDEX idx_users_created_at ON public.users(created_at DESC);

-- User permissions indexes
CREATE INDEX idx_user_permissions_user_id ON public.user_permissions(user_id);
CREATE INDEX idx_user_permissions_permission ON public.user_permissions(permission);

-- Audit log indexes
CREATE INDEX idx_audit_log_user_id ON public.audit_log(user_id);
CREATE INDEX idx_audit_log_table_name ON public.audit_log(table_name);
CREATE INDEX idx_audit_log_created_at ON public.audit_log(created_at DESC);

-- Enhanced indexes for tracking
CREATE INDEX idx_tasks_completed_by ON tasks(completed_by);
CREATE INDEX idx_tasks_created_by ON tasks(created_by);
CREATE INDEX idx_logbook_created_by ON logbook_entries(created_by);

-- =======================
-- 8. CREATE TRIGGERS
-- =======================

-- Updated_at trigger for users table
CREATE TRIGGER update_users_updated_at
    BEFORE UPDATE ON public.users
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Audit trigger function
CREATE OR REPLACE FUNCTION audit_trigger_function()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.audit_log (
        user_id,
        action_type,
        table_name,
        record_id,
        old_values,
        new_values
    ) VALUES (
        auth.uid(),
        TG_OP,
        TG_TABLE_NAME,
        COALESCE(NEW.id::text, OLD.id::text),
        CASE WHEN TG_OP = 'DELETE' THEN row_to_json(OLD) ELSE NULL END,
        CASE WHEN TG_OP IN ('INSERT', 'UPDATE') THEN row_to_json(NEW) ELSE NULL END
    );
    
    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Add audit triggers to main tables
CREATE TRIGGER audit_gardens_trigger
    AFTER INSERT OR UPDATE OR DELETE ON gardens
    FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();

CREATE TRIGGER audit_plant_beds_trigger
    AFTER INSERT OR UPDATE OR DELETE ON plant_beds
    FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();

CREATE TRIGGER audit_plants_trigger
    AFTER INSERT OR UPDATE OR DELETE ON plants
    FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();

CREATE TRIGGER audit_tasks_trigger
    AFTER INSERT OR UPDATE OR DELETE ON tasks
    FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();

-- =======================
-- 9. AUTH HOOK FUNCTION
-- =======================

CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event jsonb)
RETURNS jsonb
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  claims jsonb;
  user_role app_role;
  user_permissions text[];
  role_permissions text[];
BEGIN
  -- Fetch user role and status
  SELECT role INTO user_role 
  FROM public.users 
  WHERE id = (event->>'user_id')::uuid AND status = 'active';
  
  -- Fetch explicit user permissions
  SELECT array_agg(permission::text) INTO user_permissions 
  FROM public.user_permissions 
  WHERE user_id = (event->>'user_id')::uuid;
  
  -- Fetch role-based permissions
  SELECT array_agg(permission::text) INTO role_permissions
  FROM public.role_permissions
  WHERE role = user_role;
  
  claims := event->'claims';
  
  IF user_role IS NOT NULL THEN
    claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
    claims := jsonb_set(claims, '{user_permissions}', to_jsonb(COALESCE(user_permissions, ARRAY[]::text[])));
    claims := jsonb_set(claims, '{role_permissions}', to_jsonb(COALESCE(role_permissions, ARRAY[]::text[])));
  ELSE
    claims := jsonb_set(claims, '{user_role}', 'null'::jsonb);
  END IF;
  
  event := jsonb_set(event, '{claims}', claims);
  RETURN event;
END;
$$;

-- =======================
-- 10. AUTHORIZATION FUNCTION
-- =======================

CREATE OR REPLACE FUNCTION public.authorize(requested_permission app_permission)
RETURNS boolean
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  user_role app_role;
  has_permission boolean := false;
BEGIN
  -- Get current user role
  SELECT role INTO user_role 
  FROM public.users 
  WHERE id = auth.uid() AND status = 'active';
  
  -- Admin has all permissions
  IF user_role = 'admin' THEN
    RETURN true;
  END IF;
  
  -- Check explicit user permissions
  SELECT EXISTS(
    SELECT 1 FROM public.user_permissions 
    WHERE user_id = auth.uid() AND permission = requested_permission
  ) INTO has_permission;
  
  IF has_permission THEN
    RETURN true;
  END IF;
  
  -- Check role-based permissions
  SELECT EXISTS(
    SELECT 1 FROM public.role_permissions 
    WHERE role = user_role AND permission = requested_permission
  ) INTO has_permission;
  
  RETURN has_permission;
END;
$$;

-- =======================
-- 11. ROW LEVEL SECURITY POLICIES
-- =======================

-- Enable RLS on new tables
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_permissions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_garden_access ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.role_permissions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.audit_log ENABLE ROW LEVEL SECURITY;

-- Users table policies
CREATE POLICY "Users can view own profile" ON public.users
  FOR SELECT USING (auth.uid() = id);

CREATE POLICY "Admins can view all users" ON public.users 
  FOR SELECT USING (authorize('users.view'));

CREATE POLICY "Admins can manage users" ON public.users 
  FOR ALL USING (authorize('users.manage'));

-- User permissions policies
CREATE POLICY "Users can view own permissions" ON public.user_permissions
  FOR SELECT USING (user_id = auth.uid());

CREATE POLICY "Admins can manage permissions" ON public.user_permissions
  FOR ALL USING (authorize('users.manage'));

-- User garden access policies
CREATE POLICY "Users can view own garden access" ON public.user_garden_access
  FOR SELECT USING (user_id = auth.uid());

CREATE POLICY "Admins can manage garden access" ON public.user_garden_access 
  FOR ALL USING (authorize('users.manage'));

-- Role permissions policies  
CREATE POLICY "All authenticated users can view role permissions" ON public.role_permissions
  FOR SELECT TO authenticated USING (true);

CREATE POLICY "Only admins can modify role permissions" ON public.role_permissions
  FOR ALL USING (authorize('users.manage'));

-- Audit log policies
CREATE POLICY "Users can view own audit log" ON public.audit_log
  FOR SELECT USING (user_id = auth.uid());

CREATE POLICY "Admins can view all audit logs" ON public.audit_log
  FOR SELECT USING (authorize('users.manage'));

-- Enhanced policies for existing tables
DROP POLICY IF EXISTS "Allow all operations on gardens" ON gardens;
DROP POLICY IF EXISTS "Allow all operations on plant_beds" ON plant_beds;
DROP POLICY IF EXISTS "Allow all operations on plants" ON plants;

-- Gardens policies
CREATE POLICY "Users can view gardens" ON gardens
  FOR SELECT USING (authorize('gardens.view'));

CREATE POLICY "Users can create gardens" ON gardens
  FOR INSERT WITH CHECK (authorize('gardens.create') AND created_by = auth.uid());

CREATE POLICY "Users can update gardens" ON gardens
  FOR UPDATE USING (authorize('gardens.edit'));

CREATE POLICY "Users can delete gardens" ON gardens
  FOR DELETE USING (authorize('gardens.delete'));

-- Plant beds policies
CREATE POLICY "Users can view plant beds" ON plant_beds
  FOR SELECT USING (authorize('plant_beds.view'));

CREATE POLICY "Users can create plant beds" ON plant_beds
  FOR INSERT WITH CHECK (authorize('plant_beds.create') AND created_by = auth.uid());

CREATE POLICY "Users can update plant beds" ON plant_beds
  FOR UPDATE USING (authorize('plant_beds.edit'));

CREATE POLICY "Users can delete plant beds" ON plant_beds
  FOR DELETE USING (authorize('plant_beds.delete'));

-- Plants policies
CREATE POLICY "Users can view plants" ON plants
  FOR SELECT USING (authorize('plants.view'));

CREATE POLICY "Users can create plants" ON plants
  FOR INSERT WITH CHECK (authorize('plants.create') AND created_by = auth.uid());

CREATE POLICY "Users can update plants" ON plants
  FOR UPDATE USING (authorize('plants.edit'));

-- Tasks policies (if table exists)
DO $$
BEGIN
  IF EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'tasks') THEN
    EXECUTE 'CREATE POLICY "Users can view tasks" ON tasks FOR SELECT USING (authorize(''tasks.view''))';
    EXECUTE 'CREATE POLICY "Users can complete tasks" ON tasks FOR UPDATE USING (authorize(''tasks.complete'')) WITH CHECK (completed_by = auth.uid())';
    EXECUTE 'CREATE POLICY "Users can create tasks" ON tasks FOR INSERT WITH CHECK (authorize(''tasks.create'') AND created_by = auth.uid())';
  END IF;
END
$$;

-- =======================
-- 12. SEED DEFAULT PERMISSIONS
-- =======================

-- Insert default role permissions
INSERT INTO public.role_permissions (role, permission) VALUES
  -- Admin permissions (all)
  ('admin', 'gardens.create'),
  ('admin', 'gardens.edit'), 
  ('admin', 'gardens.delete'),
  ('admin', 'gardens.view'),
  ('admin', 'plant_beds.create'),
  ('admin', 'plant_beds.edit'),
  ('admin', 'plant_beds.delete'),
  ('admin', 'plant_beds.view'),
  ('admin', 'plants.create'),
  ('admin', 'plants.edit'),
  ('admin', 'plants.delete'),
  ('admin', 'plants.view'),
  ('admin', 'tasks.create'),
  ('admin', 'tasks.edit'),
  ('admin', 'tasks.delete'),
  ('admin', 'tasks.complete'),
  ('admin', 'tasks.view'),
  ('admin', 'logbook.create'),
  ('admin', 'logbook.edit'),
  ('admin', 'logbook.delete'),
  ('admin', 'logbook.view'),
  ('admin', 'users.invite'),
  ('admin', 'users.manage'),
  ('admin', 'users.view'),
  
  -- Regular user permissions (limited)
  ('user', 'gardens.view'),
  ('user', 'plant_beds.view'),
  ('user', 'plants.view'),
  ('user', 'tasks.complete'),
  ('user', 'tasks.view'),
  ('user', 'logbook.create'),
  ('user', 'logbook.view')
ON CONFLICT (role, permission) DO NOTHING;

-- =======================
-- 13. UTILITY FUNCTIONS
-- =======================

-- Function to get user with permissions
CREATE OR REPLACE FUNCTION get_user_with_permissions(user_uuid UUID)
RETURNS TABLE (
  id UUID,
  email TEXT,
  full_name TEXT,
  role app_role,
  status user_status,
  permissions text[]
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    u.id,
    u.email,
    u.full_name,
    u.role,
    u.status,
    COALESCE(
      ARRAY(
        SELECT up.permission::text 
        FROM user_permissions up 
        WHERE up.user_id = u.id
      ) || 
      ARRAY(
        SELECT rp.permission::text 
        FROM role_permissions rp 
        WHERE rp.role = u.role
      ),
      ARRAY[]::text[]
    ) as permissions
  FROM users u
  WHERE u.id = user_uuid;
END;
$$;

-- Function to invite user (to be called from Edge Function)
CREATE OR REPLACE FUNCTION invite_user_internal(
  user_email TEXT,
  user_role app_role DEFAULT 'user',
  inviter_id UUID DEFAULT auth.uid()
)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  new_user_id UUID;
BEGIN
  -- Check if inviter has permission
  IF NOT authorize('users.invite') THEN
    RAISE EXCEPTION 'Insufficient permissions to invite users';
  END IF;
  
  -- Generate UUID for new user (will be set when they accept invite)
  new_user_id := uuid_generate_v4();
  
  -- Insert pending user record
  INSERT INTO public.users (id, email, role, status, invited_by, invited_at)
  VALUES (new_user_id, user_email, user_role, 'pending', inviter_id, NOW());
  
  RETURN new_user_id;
END;
$$;

-- =======================
-- 14. GRANT PERMISSIONS
-- =======================

-- Grant necessary permissions for auth hooks
GRANT USAGE ON SCHEMA public TO supabase_auth_admin;
GRANT EXECUTE ON FUNCTION public.custom_access_token_hook TO supabase_auth_admin;
GRANT ALL ON TABLE public.users TO supabase_auth_admin;
GRANT ALL ON TABLE public.user_permissions TO supabase_auth_admin;
GRANT ALL ON TABLE public.role_permissions TO supabase_auth_admin;

-- Grant permissions to authenticated users
GRANT USAGE ON SCHEMA public TO authenticated;
GRANT ALL ON ALL TABLES IN SCHEMA public TO authenticated;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO authenticated;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO authenticated;

-- =======================
-- 15. VERIFICATION QUERIES
-- =======================

-- Verify tables created
SELECT 'Users table created' as status WHERE EXISTS (
  SELECT FROM information_schema.tables WHERE table_name = 'users'
);

SELECT 'User permissions table created' as status WHERE EXISTS (
  SELECT FROM information_schema.tables WHERE table_name = 'user_permissions'  
);

SELECT 'Role permissions seeded' as status WHERE EXISTS (
  SELECT FROM role_permissions WHERE role = 'admin' LIMIT 1
);

-- Show role permissions count
SELECT 
  role,
  count(*) as permission_count
FROM role_permissions 
GROUP BY role;

COMMENT ON TABLE public.users IS 'Application users with roles and permissions';
COMMENT ON TABLE public.user_permissions IS 'Explicit permissions granted to specific users';
COMMENT ON TABLE public.role_permissions IS 'Default permissions for each role';
COMMENT ON TABLE public.audit_log IS 'Audit trail for all user actions';

-- =======================
-- 14. ADMIN HELPER FUNCTIONS
-- =======================

-- Function to create user profile (bypasses RLS)
CREATE OR REPLACE FUNCTION create_user_profile(
  p_user_id UUID,
  p_email TEXT,
  p_role app_role,
  p_status user_status,
  p_full_name TEXT
)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  INSERT INTO public.users (id, email, role, status, full_name, avatar_url, created_at)
  VALUES (p_user_id, p_email, p_role, p_status, p_full_name, null, NOW())
  ON CONFLICT (id) DO UPDATE SET
    role = p_role,
    status = p_status,
    full_name = p_full_name,
    updated_at = NOW();
END;
$$;

-- Function to ensure admin user exists
CREATE OR REPLACE FUNCTION ensure_admin_user()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  INSERT INTO public.users (id, email, role, status, full_name, avatar_url)
  SELECT id, email, 'admin', 'active', 'System Administrator', null
  FROM auth.users 
  WHERE email = 'admin@tuinbeheer.nl'
  ON CONFLICT (id) DO UPDATE SET 
    role = 'admin', 
    status = 'active',
    full_name = 'System Administrator',
    updated_at = NOW();
END;
$$;

-- Run admin user creation
SELECT ensure_admin_user();

-- =======================
-- Migration Complete!
-- =======================